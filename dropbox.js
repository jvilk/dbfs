// Generated by CoffeeScript 1.6.3
(function() {
  var _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.db = window.Dropbox;

  BrowserFS.File.DropboxFile = (function(_super) {
    __extends(DropboxFile, _super);

    function DropboxFile() {
      _ref = DropboxFile.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    DropboxFile.prototype.sync = function() {
      return this._fs.client.writeFile(this._path, this._buffer.buff.getBuffer(), function(error, stat) {
        if (error) {
          return console.log(error);
        }
      });
    };

    DropboxFile.prototype.close = function() {
      return this.sync();
    };

    return DropboxFile;

  })(BrowserFS.File.PreloadFile);

  BrowserFS.FileSystem.Dropbox = (function(_super) {
    __extends(Dropbox, _super);

    function Dropbox(testing) {
      var _this = this;
      if (testing == null) {
        testing = false;
      }
      this.init_client = new db.Client({
        key: 'u8sx6mjp5bxvbg4',
        sandbox: true
      });
      if (testing) {
        this.init_client.setCredentials({
          key: "u8sx6mjp5bxvbg4",
          token: "mhkmZQTE4PUAAAAAAAAAAYyMdcdkqvPudyYwmuIZp3REM1YvV9skdtstDBYUxuFg",
          uid: "4326179"
        });
      } else {
        this.init_client.authDriver(new db.AuthDriver.Redirect({
          rememberUser: true
        }));
      }
      this.init_client.authenticate(function(error, authed_client) {
        if (error) {
          console.error('Error: could not connect to Dropbox');
          console.error(error);
          return;
        }
        authed_client.getUserInfo(function(error, info) {
          return console.debug("Successfully connected to " + info.name + "'s Dropbox");
        });
        return _this.client = authed_client;
      });
    }

    Dropbox.prototype.getName = function() {
      return 'Dropbox';
    };

    Dropbox.isAvailable = function() {
      return true;
    };

    Dropbox.prototype.isReadOnly = function() {
      return false;
    };

    Dropbox.prototype.supportsSymlinks = function() {
      return false;
    };

    Dropbox.prototype.supportsProps = function() {
      return false;
    };

    Dropbox.prototype.supportsSynch = function() {
      return false;
    };

    Dropbox.prototype.empty = function(cb) {
      var fs;
      fs = this;
      return fs.client.readdir('/', function(error, paths, dir, files) {
        var file, i, status, _i, _len, _results;
        status = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            _results.push(false);
          }
          return _results;
        })();
        _results = [];
        for (i = _i = 0, _len = files.length; _i < _len; i = ++_i) {
          file = files[i];
          _results.push(fs.client.remove(file.path, function(error, stat) {
            status[i] = true;
            if (__indexOf.call(status, false) < 0) {
              cb();
            }
          }));
        }
        return _results;
      });
    };

    Dropbox.prototype.rename = function(oldPath, newPath, cb) {
      return this.client.move(oldPath, newPath, function(error, stat) {
        var type;
        if (error) {
          return cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, "" + path + " doesn't exist"));
        } else {
          type = stat.isFile ? BrowserFS.node.fs.Stats.FILE : BrowserFS.node.fs.Stats.DIRECTORY;
          stat = new BrowserFS.node.fs.Stats(type, stat.size);
          return cb(null, stat);
        }
      });
    };

    Dropbox.prototype.stat = function(path, isLstat, cb) {
      return this.client.stat(path, {}, function(error, stat) {
        var type;
        if (error) {
          console.log(error);
          return cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, "doesn't exist " + path));
        } else {
          type = stat.isFile ? BrowserFS.node.fs.Stats.FILE : BrowserFS.node.fs.Stats.DIRECTORY;
          stat = new BrowserFS.node.fs.Stats(type, stat.size);
          return cb({
            message: path
          }, stat);
        }
      });
    };

    Dropbox.prototype.open = function(path, flags, mode, cb) {
      var fs,
        _this = this;
      fs = this;
      return fs.client.readFile(path, {
        arrayBuffer: true
      }, function(error, content, db_stat, range) {
        var file;
        if (error) {
          if (__indexOf.call(flags, 'r') >= 0) {
            cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, "" + path + " doesn't exist "));
          } else {
            switch (error.status) {
              case 0:
                console.error('No connection');
                return;
              case 404:
                console.debug("" + path + " doesn't exist, creating...");
                content = '';
                fs.client.writeFile(path, content, function(error, stat) {
                  var file;
                  db_stat = stat;
                  file = fs._convertStat(path, mode, db_stat, content);
                  return cb(null, file);
                });
                return;
              default:
                console.log(error);
                return;
            }
          }
        } else {
          file = fs._convertStat(path, mode, db_stat, content);
          cb(null, file);
        }
      });
    };

    Dropbox.prototype._statType = function(stat) {
      if (stat.isFile) {
        return BrowserFS.node.fs.Stats.FILE;
      } else {
        return BrowserFS.node.fs.Stats.DIRECTORY;
      }
    };

    Dropbox.prototype._convertStat = function(path, mode, stat, data) {
      var buffer, type;
      type = this._statType(stat);
      stat = new BrowserFS.node.fs.Stats(type, stat.size);
      data || (data = '');
      buffer = new BrowserFS.node.Buffer(data);
      mode = new BrowserFS.FileMode('w');
      return new BrowserFS.File.DropboxFile(this, path, mode, stat, buffer);
    };

    Dropbox.prototype._remove = function(path, cb) {
      return this.client.remove(path, function(error, stat) {
        if (error) {
          return cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, "Failed to remove " + path));
        } else {
          return cb(null);
        }
      });
    };

    Dropbox.prototype.unlink = function(path, cb) {
      return this._remove(path, cb);
    };

    Dropbox.prototype.rmdir = function(path, cb) {
      return this._remove(path, cb);
    };

    Dropbox.prototype.mkdir = function(path, mode, cb) {
      return this.client.mkdir(path, function(error, stat) {
        if (error) {
          return cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, "" + path + " already exists"));
        } else {
          return cb(null);
        }
      });
    };

    Dropbox.prototype.readdir = function(path, cb) {
      return this.client.readdir(path, function(error, files, dir_stat, content_stats) {
        return cb(error, files);
      });
    };

    Dropbox.prototype.writeFile = function(path, data, encoding, flag, mode, cb) {
      var fs;
      fs = this;
      if (typeof data === 'string') {
        data = new BrowserFS.node.Buffer(data, encoding);
      }
      return this.client.writeFile(path, data.buff.getBuffer(), function(error, stat) {
        var file;
        file = fs.convertStat(path, mode, stat, data);
        return cb(null, file);
      });
    };

    Dropbox.prototype.readFile = function(path, encoding, flag, cb) {
      var fs,
        _this = this;
      fs = this;
      return fs.client.readFile(path, function(error, content, stat, range) {
        if (error) {
          cb(new BrowserFS.ApiError(BrowserFS.ApiError.INVALID_PARAM, "No such file: " + path));
          switch (error.status) {
            case 0:
              return console.error('No connection to Dropbox');
            case 404:
              return console.log("" + path + " doesn't exist");
            default:
              return console.log(error);
          }
        } else {
          return cb(null, new BrowserFS.node.Buffer(content, encoding).toString(encoding));
        }
      });
    };

    return Dropbox;

  })(BrowserFS.FileSystem);

}).call(this);
